package main

//build:ignore

// taken from: https://github.com/Zyko0/kage-shaders/tree/main/crt/mattias
// which is a port of: https://www.shadertoy.com/view/Ms23DR
// kage:unit pixels

// curve function applies a distortion effect to the uv coordinates
func curve(uv vec2) vec2 {
	uv = (uv - 0.5) * 2 // Shift UV coordinates to range [-1, 1]
	uv *= 1.1           // Scale UV coordinates slightly

	// Apply non-linear transformations to UV coordinates
	uv.x *= (1 + pow((abs(uv.y)/5), 2))
	uv.y *= (1 + pow((abs(uv.x)/4), 2))

	uv = uv/2 + 0.5     // Shift UV coordinates back to range [0, 1]
	uv = uv*0.92 + 0.04 // Further scale and offset UV coordinates

	return uv // Return the transformed coordinates
}

// Fragment function determines the color of each pixel
func Fragment(dst vec4, src vec2, color vec4) vec4 {
	origin, size := imageSrcRegionOnTexture() // Get texture origin and size
	q := (src - origin) / size                // Normalize source coordinates
	uv := q
	uv = curve(uv) // Apply the curve distortion to UV

	var col vec3 // Initialize color vector

	// Sample texture at slightly offset coordinates for RGB channels
	// and add a small constant to each channel
	col.r = imageSrc0At(vec2(uv.x+0.001, uv.y+0.001)*size+origin).x + 0.05
	col.g = imageSrc0At(vec2(uv.x+0.000, uv.y-0.002)*size+origin).y + 0.05
	col.b = imageSrc0At(vec2(uv.x-0.002, uv.y+0.000)*size+origin).z + 0.05

	// Further modify color channels with more sampled data
	col.r += 0.08 * imageSrc0At((0.75*vec2(0.025, -0.027)+vec2(uv.x+0.001, uv.y+0.001))*size+origin).x
	col.g += 0.05 * imageSrc0At((0.75*vec2(-0.022, -0.02)+vec2(uv.x+0.000, uv.y-0.002))*size+origin).y
	col.b += 0.08 * imageSrc0At((0.75*vec2(-0.02, -0.018)+vec2(uv.x-0.002, uv.y+0.000))*size+origin).z

	// Clamp color values and apply gamma correction
	col = clamp(col*0.6+0.4*col*col, 0, 1)

	// Calculate vignette effect based on UV coordinates
	vig := (16.0 * uv.x * uv.y * (1 - uv.x) * (1 - uv.y))
	col *= vec3(pow(vig, 0.3)) // Apply vignette effect with power function

	// Color grading, slightly altering color channels
	col *= vec3(0.95, 1.05, 0.95)
	col *= 2.8 // Overall brightness boost

	// Apply scanline effect based on Y coordinate
	scans := clamp(0.35+0.35*sin(uv.y*size.y*1.5), 0, 1)
	s := pow(scans, 1.7)
	col *= vec3(0.4 + 0.7*s)

	// Check if UV coordinates are out of bounds and set color to black if so
	if uv.x < 0.0 || uv.x > 1.0 || uv.y < 0 || uv.y > 1 {
		col *= 0
	}

	// Further modify color based on X coordinate (stripes effect)
	col *= (1 - 0.65*vec3(clamp((mod(src.x, 2)-1)*2, 0, 1)))

	return vec4(col, 1) // Return the final color with full opacity
}
